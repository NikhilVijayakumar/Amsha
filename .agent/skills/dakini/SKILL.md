---
name: dakini
description: Auto-generates paper_config.yaml by intelligently detecting modules, analyzing their purpose, and creating a comprehensive configuration for research paper generation.
priority: standard
---

# Dakini (Paper Config Generator)

## Activation Triggers
- `"Dakini"` or `"dakini"`
- `"Generate paper config"`
- `"Create paper configuration"`
- `"Setup paper generation"`

## Purpose
Dakini automatically scans your codebase to detect modules, analyzes their purpose and importance, and generates a comprehensive `paper_config.yaml` file. This eliminates manual configuration and ensures all relevant modules are included in your research paper generation workflow.

## Workflow

### 1. Module Discovery

**Scan Source Directory:**
```python
# Example: Scan src/nikhil/amsha/ or src/{package}/
base_path = "src/nikhil/amsha"
modules = [d for d in listdir(base_path) if is_directory(d)]
```

**Filter Criteria:**
- Must contain `.py` files (not just `__init__.py`)
- Exclude common utility patterns: `__pycache__`, `.pytest_cache`, `tests`
- Minimum 2 Python files to qualify as a module

### 2. Module Analysis

For each discovered module, analyze:

**Priority Detection:**
```python
# Critical: Contains domain models, core algorithms, or "main" logic
# High: Contains business logic, orchestration, or processing
# Medium: Contains utilities, factories, or helpers
# Low: Contains purely auxiliary functions
```

**Indicators:**
- **Critical**: Files with names like `core.py`, `engine.py`, `repository.py`, or contains Pydantic models
- **High**: Files with names like `manager.py`, `processor.py`, `service.py`
- **Medium**: Files with names like `factory.py`, `builder.py`, `adapter.py`
- **Low**: Files with names like `utils.py`, `helpers.py`, `common.py`

**Description Generation:**
Read the module's `__init__.py` docstring or first `.py` file's module-level docstring to extract purpose.

**Focus Areas Identification:**
```python
# Scan for common patterns:
- "repository" ‚Üí repository_pattern
- "Protocol" class ‚Üí clean_architecture
- "Builder" suffix ‚Üí builder_pattern
- "Factory" suffix ‚Üí factory_pattern
- "manager" ‚Üí orchestration
- Statistical functions ‚Üí algorithms
```

### 3. Configuration Generation

**Template:**
```yaml
# Paper Generation Configuration
# Auto-generated by Dakini on {timestamp}

generation:
  mode: modular
  auto_detect_modules: true
  depth: comprehensive

modules:
{for each module}
  - name: {module_name}
    path: src/{package}/{module_name}
    description: "{auto_detected_description}"
    priority: {critical|high|medium|low}
    include_in_final: {true|false}  # false only if priority=low by default
    focus_areas:
      - {detected_pattern_1}
      - {detected_pattern_2}
{end for}

exclusions:
  skip_test_files: true
  skip_example_files: true
  skip_init_files: true

output:
  base_dir: docs/paper
  modules_dir: ${base_dir}/modules
  cross_module_dir: ${base_dir}/cross_module
  final_draft: ${base_dir}/drafts/FINAL_JOURNAL_REPORT.md
  appendix_dir: ${base_dir}/appendix

analysis:
  mathematics:
    min_algorithms_per_module: 1
    include_edge_cases: true
    include_complexity_analysis: true
    variable_mapping: required
  
  architecture:
    min_diagrams_per_module: 2
    diagram_types:
      - class_diagram
      - sequence_diagram
      - component_diagram
    include_dependency_analysis: true
  
  gaps:
    severity_levels:
      - critical
      - moderate
      - minor
    include_remediation_plan: true
    estimate_effort: true

synthesis:
  combine_similar_algorithms: false
  deduplicate_gaps: true
  cross_reference_modules: true
  
  final_structure:
    - abstract
    - introduction
    - related_work
    - module_analyses
    - cross_module_analysis
    - system_level_performance
    - discussion_and_future_work
    - conclusion
    - appendix

quality:
  min_latex_equations: {num_modules * 2}
  min_diagrams: {num_modules * 2}
  min_identified_gaps: {num_modules * 3}
  min_code_references: 50

execution:
  parallel_module_analysis: false
  pause_between_modules: true
  generate_progress_reports: true
  
  processing_order:
    {modules sorted by priority: critical ‚Üí high ‚Üí medium ‚Üí low}

verification:
  cross_check_variable_names: true
  verify_all_code_references: true
  validate_diagram_accuracy: true
  check_gap_uniqueness: true
  
  per_module_checks:
    - algorithms_have_source_refs
    - diagrams_reflect_actual_code
    - gaps_are_code_verified
    - complexity_analysis_present
```

### 4. Smart Defaults

**Include/Exclude Logic:**
```python
if priority in ['critical', 'high']:
    include_in_final = true
elif priority == 'medium' and has_algorithms():
    include_in_final = true
else:
    include_in_final = false  # User can manually enable
```

**Processing Order:**
Sort by:
1. Priority (critical first)
2. Complexity (more complex modules first for context)
3. Alphabetical

### 5. Output

**File:** `.agent/paper_config.yaml`

**Conflict Handling:**
- If file exists: Create backup as `.agent/paper_config.yaml.bak`
- Prompt user: "Config exists. Overwrite, merge, or cancel?"

**Post-Generation:**
Display summary:
```
‚úÖ Generated paper_config.yaml
üì¶ Detected {N} modules:
   - {N_critical} critical priority
   - {N_high} high priority
   - {N_medium} medium priority
   - {N_low} low priority (excluded by default)

üéØ Next Steps:
1. Review .agent/paper_config.yaml
2. Adjust module priorities if needed
3. Run: "Lutapi, generate research paper"
```

## Example Usage

**Basic:**
```
"Dakini, generate the paper config."
```

**With Override:**
```
"Dakini, scan src/nikhil/amsha and create paper config."
```

**Regenerate:**
```
"Dakini, regenerate paper config (backup existing)."
```

## Verification Requirements

Before writing the config file:
- ‚úÖ All detected modules have valid paths
- ‚úÖ At least one module has `priority: critical`
- ‚úÖ Descriptions are meaningful (not "No description")
- ‚úÖ Focus areas are evidence-based (not guessed)
- ‚úÖ Processing order is logical

## Edge Cases

**No Modules Detected:**
```
‚ö†Ô∏è No modules found in src/{package}.
Please check your project structure.
```

**Single Module:**
```
‚ö†Ô∏è Only 1 module detected. Consider using unified mode instead.
Generating config with mode: unified
```

**Too Many Modules (>15):**
```
‚ö†Ô∏è {N} modules detected. This is quite large.
Consider grouping related modules or using selective inclusion.
```

## Related Skills

- [Journal Master](../journal-master/SKILL.md) - Uses the generated config to create papers
- [Package Maintainer](../package-maintainer/SKILL.md) - Helps identify module structure
- [Doc Architect](../doc-architect/SKILL.md) - Can suggest module descriptions

## Tips

- Run Dakini whenever you add new modules to your project
- Review the generated config before running Lutapi
- Adjust `include_in_final` for utility modules
- Use `description` field to add context for reviewers
- Update `focus_areas` to highlight novel contributions

## Supporting Materials

### Scripts
- **[generate_config.py](scripts/generate_config.py)** - Python implementation of module detection and config generation logic. Can be run independently for testing.

### Examples
- **[generated_config_example.md](examples/generated_config_example.md)** - Complete example showing what Dakini produces from a typical project

### Resources
- **[priority_matrix.md](resources/priority_matrix.md)** - Decision matrix for determining module priorities and focus areas when auto-detection is ambiguous

## Quality Indicators

When using these materials, ensure:
- **Script:** All detected modules have valid paths and at least one has critical priority
- **Example:** Generated config matches the documented structure
- **Priority Matrix:** Use the flowchart for consistent priority assignment
